html：
div和span区别
      div：块级元素，每个div标签会独占一行，可通过css样式来设置自身宽度、高度，标签之间的内外边距，还可以在div标签中使用其他行内或块级元素。
      span：行内元素，会和其他标签元素在一行显示，不会另起一行，span标签无法设置高度和宽度，可以设置左右的内外边距，但不能设置上下的内外边距，span标签内只能容纳文本或其他行内元素，不能容纳块级元素。


css布局方式有几种？
       静态布局（float布局，绝对布局），自适应布局，流式布局（百分比布局%），响应式布局（媒体查询），弹性布局


css的使用方式哪几种
      1.行内样式：只对当前标签生效
      2.内联样式：将css代码集中写在html文档的head头部标签中
      3.外链样式：将所有样式放在一个或者多个css文件中，通过link标签连接到html文档中

选择器有哪几种？
       1. 元素选择器    标签名{ }
       2. id选择器          #id{ }
       3. 类选择器          .类名{ }
       4.分组选择器（常用于集体声明）  选择器1，选择器n { }
       5.复合选择器（交集选择器）   选择器1选择器2选择n
       6.通配选择器        *{ }
       7.后代选择器（选中指定元素的指定后代元素）       祖先元素  后代元素{ }
       8.子元素选择器     父>子{  }
       9.伪类选择器   :hover  鼠标移入元素的状态，:visited已被访问的元素状态， :active 被惦记时元素的状态
       10.属性选择器 （根据元素中的属性或属性值来选取指定元素）
       11.兄弟元素选择器   “+”选择器（作用在后一个）：（选中一个元素后紧挨着的指定兄弟元素） 前一个+后一个{  }  ；“~”选择器：选中后面所有的指定兄弟元素  前一个~后边所有
    

优先级怎么算？

       css属性+!important>内联样式>ID选择器>类选择器=伪类选择器=属性选择器>元素选择器=伪元素选择器>通用选择器>继承的样式


rem单位是怎么换算的？
........


微信小程序rpx是怎么换算的？



用过哪些css3属性

      text-overflow：规定当文本溢出包含元素时发生的事情、text-shadow：文本阴影、border-radius：圆角边框、box-shadow：方框阴影、background-size：背景图片的尺寸、transform：2D、3D转换、transtion：过渡属性（四个）、@keyframes：动画、box-sizing


弹性布局有哪些属性
1. flex-direction:项目的排列方向（主轴的方向）
    row：主轴为左端水平方向
    row-reverse：主轴为右端水平方向
    column：主轴为上沿垂直方向
    column-reverse：主轴为下沿垂直方向

2.flex-wrap：轴线上的换行方式
        nowrap：（默认）不换行
        wrap：换行，第一行在上方
        wrap-reverse：换行，第一行在下方

3.flex-flow：flex-direction属性和flex-wrap属性的简写，默认：row nowrap

4.justify-content：项目在主轴上的对齐方式
        flex-start：（默认）左对齐
        flex-end：右对齐
        center：居中对齐
        space-between：两端对齐，项目之间间隔相等
        space-around：四周型对齐方式  项目两侧的间隔相等

5.align-item：项目在交叉轴上的对齐方式
                   flex-start：交叉轴的起点对齐（垂直顶端对齐）
                     flex-end：交叉轴的终点对齐（垂直底端对齐）
                         center：交叉轴的中点对齐（垂直居中对齐）
                      baseline：项目的第一行文字的基线对齐
                        stretch：（默认）如果项目未设置高度或auto，将占满整个容器的高度

6.align-content：多根轴线的对齐方式
                    flex-start：与交叉轴的起点对齐（垂直顶端对齐）
                      flex-end：与交叉轴的终点对齐（垂直底端对齐）
                           center：与交叉轴的中点对齐（垂直居中对齐）
       space-between：与交叉轴两端对齐，间隔平均分布
           space-around：四周型对齐方式
                          stretch：（默认）轴线占满整个交叉轴

7.order：定义项目的排列顺序。数值越小，排列越靠前，默认为0
8.flex-grow：项目的放大比例，默认为0
9.flex-shrink：项目的缩小比例，默认为1
10.flex-basis：定义在分配多余空间之前，项目占据的主轴空间（main size），默认auto，即项目本来大小
11.flex：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选
12.align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认auto：表示继承父元素的align-items属性


order属性干嘛的
     order：定义弹性布局中项目的排列顺序。数值越小，排列越靠前，默认为0



媒体查询怎么写？
    @media mediatype and/not/only (media feature){ css样式}
   
    @media:声明媒体查询
    mediatype：规定媒体的类型，包括：all（所有设备）、print（打印机）、screen（屏幕）、speech（屏幕阅读器）
    media feature：媒体特性  写法：属性名：属性值（min-width：700px）
    逻辑运算符：not：排除某种设备；only：指定某种特定设备；and：连接多种媒体特性，一个媒体查询可包含0或多个表达式



js数据类型有哪几种？
      number（数值）、string（字符串）、undefined（未定义）、null（空值）、bool（布尔值）、object



新增的h5标记
    header：网站头部区域、nav：网站导航、section：网页的某一模块、footer：网页的页脚等
    


css：
box-sizing盒模型

    将border、padding计算到width和height中，使页面更灵活。
    该属性包括content-box和border-box两个值
    content-box：定义width和height时，宽度不包括border和padding
    border-box：定义width和height时，border和padding被包含在宽高以内
  

常用的几种布局方式

       静态布局（float布局，绝对布局），自适应布局，流式布局（百分比布局%），响应式布局（媒体查询），弹性布局


css的选择器种类和优先级判定
    
     选择器：元素选择器、id选择器、类选择器、后代选择器、子代选择器、兄弟选择器、相邻选择器、群组选择器、全局选择器、属性选择、伪类选择器、选择器优先级

      优先级：!important>行间样式> ID选择器>属性选择器&&伪类选择器>类选择器>元素选择器



不知宽高的盒子如何居中(水平和垂直)

flex 布局 12个属性

css 的适配方案
定位
translate

 js动态获取视图宽高



js:
DOM和BOM
   
   DOM：文档对象模型。定义了处理网页内容的方法和接口
   BOM：浏览器对象。将浏览器当做对象来使用，定义了与浏览器进行交互的方法和接口
   DOM的最根本对象是BOM的window对象的子对象


js的事件流
   
   事件流：事件的执行流程顺序
   1 捕获事件：从外往里触发事件
   2 目标事件：直接绑定在元素上的DOM0级事件
   3 冒泡事件：从里往外触发事件（默认）
   
  事件捕获：从最外层往里层，事件冒泡：从最里层到最外层
   

this和target指向
    this:指向当前事件所绑定的元素；
    target：指向事件执行时点击区域的元素
    当鼠标所点击的元素有子元素时，target指向子元素，没有则跟this指向一样

     this指向事件源
     event.target永远指向事件触发时最底层的元素

数组和字符串常用的api

  数组：arr.push()数组末尾添加元素----arr.unshift:数组开头添加一个元素----arr.shift:删除并返回第一个元素----arr.pop()删除并返回最后一个元素----arr.reverse()反序排列数组元素----arr.sort()正序排列数组----arr.splice()截取数组片段----arr.slice()复制数组片段----arr.concat()多个数组合并----arr.join()连接数组形成字符串。
   数组遍历：forEach----find：查找第一个符合return的结果并返回----filter：查找并返回所有符合return的结果----findIndex：查找并返回第一个符合return结果的索引值----some:return结果为true时停止遍历并返回true，没有则false----every：return为false时返回false，没有为true----map：把return的结果返回形成新数组
   
   字符串：str.length:读取字符串长度----str.indexOf():读取字符所在索引值，没有为-1----str.toUpperCase:大写----str.toLowerCase:小写----str.substr:复制字符串片段（从索引值开始到该后面几个成员）----str.substring:复制片段（从索引值开始到整个字符串第几个成员）----str.split()分割字符串形成数组----str.replace（）:替换字符串


闭包(是什么,能用来做什么,会产生什么影响)

   闭包是指有权访问另外一个函数作用域中的变量的函数
   闭包可以读取函数内部的变量，同时让这些变量的值始终保持在内存中
   由于该功能，内存消耗很大，滥用闭包可能会导致内存泄漏问题


跨域(为什么会产生跨域,跨域的解决方案)

   跨域是指一个域下的文档或脚本试图去请求另一个域下的资源

   跨域是为了解决不同源网页之间可以授权读取对方资源的操作
   解决方案：1.JSONP---get请求；2.CORS 跨域资源共享。。。


get和post请求的区别

  get：不安全，数据暴露；传送的数据量小，限制form表单的数据集的值必须是ASCII字符；执行效率比post方法好
  post：保密性好，数据不易泄露；传输数据量较大；支持整个ISO10646字符集。


工厂模式，构造函数，原型函数...

  工厂模式：在函数内创建一个对象，给对象赋予属性及方法再将对象返回

  构造函数：函数名与类名相同。无返回值。编译器自动调用对应的构造函数。构造函数可以重载。
  
  原形函数：解决数据共享，节省内存空间，实现继承。实例对象原型：__proto__:浏览器使用；构造函数原型：prototype：程序员使用。



call和apply的区别
   
  都是调用函数，传递参数，借用其他函数的方法，改变函数内部的this指向。
  call传递的参数用逗号隔开，apply方法执行传递数组

js方法的继承
  1.构造函数方法继承（用call()，apply()方法）将父构造函数的this指向子构造函数的实例，从而实现继承
  
  2.原型链继承：prototype

  3.组合继承:将原型链和构造函数方法结合起来用

==和===的区别
==：等值   ===：等值及等址

node：
常用的模块有哪些
   http  fs  path  url mime querystring art-template  multer  jsonwebtoken
   http：网络通信  fs:文件读写  path:路径  url:请求地址
   querystring：实现URL参数字符串与参数对象的互相转换
   mime：动态读取文件类型
   art-template：模板渲染数据
   multer：文件上传
   jsonwebtoken：token令牌

   1.http:处理网络客户端的请求；
   2.URL:处理客户端请求过来的url；
   3.querystrings:处理客户端通过get/post请求传递过来的参数；
   4.filesystem（fs）:在客户端操作文件
   5.path：操作文件的路径，为文件操作服务


本地安装和全局安装的区别
  1.安装位置不同，本地是将模块下载到当前命令行所在的目录，全局模块被下载安装到全局目录中。
  2.调用方式不同：本地安装可通过require()的方式引入，全局安装不行
 


什么是错误优先的回调函数？
   错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据，其中第一个参数返回错误，并且验证它是否出错；其他参数返回数据。



express的功能
  是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。

  



怎么操作mongodb（增删改查）
deleteOne：删除一条  deleteMany：删除多条
updateOne，updateMany：更新
findOne，find：查找



es：
var 和 let const的区别
  var定义的变量可以有变量提升（可以预解析提前调用的结果是undefined）  let和const定义的变量不能预解析；
  var定义的变量，其名称可以重复，效果是重复赋值，let和const定义的变量名不能重复，否则报错；
  var定义的变量作用域：全局/局部，let和const定义的变量只能在块中使用（{}）；
  var定义的变量在循环中和let定义的变量执行原理和执行效果不同
  const定义的变量存储的数据数值不能改变，也就是不能重复赋值。


js的几种作用域

全局、局部、块级

  

新增数据类型

 Symbol：表示独一无二的值

箭头函数与普通函数的区别
  this指向不同，箭头函数中没有this；箭头函数不能作为构造函数，不能使用new关键字；不绑定arguments，如果存在多余参数，可以使用rest解决；箭头函数会捕获上下文的this作为自己的this；箭头函数没有原型对象，不能在原型对象上添加方法，不能作为生成器函数。


解构赋值


Symbol的作用

promise 封装ajax



异步 (async await promise)

es类的继承
  属性继承



set和map区别
 
  都支持快速查找和删除，都是关联式容器，一般使用rb树来实现，不存在内存移动也就不容易出现迭代器失效的问题，所有元素都会被自动排序
   
  set:对象形式的数组。不能通过迭代器修改set的值，不允许出现键值重复

  map:数组形式的对象。所有元素都是键值存在，不允许出现键重复，键不能修改，其值可以修改




vue：

data为什么是函数
   vue中组件是用来复用的，为了防止data复用，将其定义为函数
   防止组件之间的数据产生污染，如果data是对象的话，各组件的data会合并，指向同一个地址，如果是函数，合并的时候调用会产生不同的空间。



常用v指令

       v-bind、v-on、v-if、v-for、v-show、v-model、v-html、v-once




写过哪些常用自定义指令

       v-big：字母小写转大写
       v-sum：计算两数之和



vue中key的作用和原理

    vue在patch过程中，通过key可以判断出两个虚拟节点是否是相同节点，没有key会导致更新的时候出问题。




vue双向数据绑定原理
       页面上控件输入的值同步更新到相关绑定的data属性，在更新data绑定属性时同步更新页面上输入控件的值

       采用“数据劫持”结合“发布者-订阅者”模式的方式，通过“Object.defineProperty()”方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。


vue常用修饰符

 按键修饰符：.up、.down、.ctrl、.enter、.space
 事件修饰符：.prevent:阻止事件默认行为；.stop:阻止事件冒泡；.self:只触发自己范围内的事件(不包括子元素)；.capture:事件捕获；.once:只触发一次

  修饰符可以串联使用



vue中如何检测数组的变化

   利用数组的方法来实现：push(尾部添加)、pop(尾部删除)、unshift(头部添加)、shift(头部删除)、splice(截取数组片段)、sort(正序)、reverse(反序)



vue 生命周期(哪一步能做什么)

   vue生命周期：vue生命周期是指vue实例从创建到销毁的过程。生命周期的不同阶段用对应的钩子函数来实现组件数据管理和dom渲染

    beforeCreate：vue实例初始化之前调用；数据和事件还没初始化(没有data，el),不能获取dom节点

    created：vue实例初始化之后调用；实例已创建，数据观测，属性和方法的运算，watch/event事件回调等配置都已经完成，不能获取dom节点（$el还没生成）

    beforeMount：挂载到dom树之前调用，vue挂载的根节点已经创建(data,el)，不能获取dom节点

    mounted：挂载到dom树之后调用 ，数据和dom都被渲染出来

    
    keep-alive:组件保持活性  （activated组件激活时调用/deactivated组件停用时调用）


    beforeUpdate：数据更新前调用，检测到数据更新时，dom更新前调用

    updated：数据更新之后调用 

    beforeDestroy：vue实例销毁之前调用 

    destroyed：vue实例销毁时调用，vue实例的所有东西都被解绑，所有事件监听会被溢出，子实例被销毁



vue 父子组件的生命周期执行顺序
    父 beforeCreate-->父 created-->父 beforeMount-->子beforeCreate-->子created-->子 beforeMount-->子 mounted-->父mounted-->父beforeUpdate-->子 beforeUpdate-->父updated-->子 updated-->父beforeDestroy-->子 beforeDestroy-->子 destroyed-->父destroyed




vue 父子传值

    一、父传子
          1.通过自定义属性传值，子组件通过props接收
          2.子组件通过slot插槽标签接收父组件标记里面的内容
    二、子传父
          1.子组件通过$emit自定义事件触发，父组件随时监听事件执行来实现传值
          2.通过ref命名传值（父组件触发）
    三、子传子
           通过事件总线的方式传值（需要修改main.js）




vue路由跳转


       path跳转页面
       name跳转页面  


vue路由跳转接收参数
    布尔模式：name传参，当props设置为true时，route.params 将被设置为组件的 props。
    函数模式：path传参，创建一个返回props的函数，path属性配合query传值
    对象模式：当props是一个对象时，将原样设置为组件props

     params，query


vue路由导航钩子函数
       全局钩子：beforeEach、afterEach、beforeResolve  :无论访问哪一个路径，都会触发全局的钩子函数

       局部路由钩子：beforeEnter  :写在路由配置中，只有访问到这个路径，才能触发钩子函数

       组件路由：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave  :写在组件中,访问路径，即将渲染组件的时候触发的




vue-router 实现原理
      原理：vue-router是前端路由，当路径切换的时候在浏览器端判断当前路径，并加载当前路径对应的组件，有两种模式：
       hash模式：以url中#后面的内容作为路由地址，可以直接通过location.url来切换浏览器的地址，当hash改变后，要监听hash的变化，并做响应的处理，可以监听hashchange事件，当hash发生变化时，会触发hashchange事件，在此事件中记录当前路由地址，并找到当前路由对应的组件，重新渲染在浏览器中。 可通过mode:"history"的方式更改hash模式为history模式。

     兼容性好，

        history模式：路径就是普通的url，通过history.pushState()方式来改变地址栏，并把当前地址记录在浏览器的访问历史中，并不会真正的跳到指定的路径，也就是说浏览器不会向服务器发送。
        



vue-router的组件
  
   router-link、router-view、keep-alive



vue中$nextTick的理解
 
    在下次dom更新循环结束之后执行延迟回调。在修改数据后立即使用这个方法，获取更新后的dom
    
    当数据更新之后并没有完成视图更新时，使用Vue.nextTick()

    想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick()
  
     vue中的数据更新是异步的，使用nextTick可以保证定义的逻辑在更新之后执行。



watch 与 component 的区别
    watch：侦听器；观测vue实例中数据的变化，数据一旦变化就执行function中的语句，函数中提供new和old两个参数（改变后和改变前的数据）
    component：组件；组件可以扩展HTML元素，封装可重用的代码。



watch和computed的区别及用法
  
   watch和computed都是vue框架中基于watcher实现的，用于数据监听

   computed：计算属性，具备缓存，所依赖的属性不变  对其取值时计算属性方法不会重复执行，必须有return，computed一般用于当一个属性受多个属性影响时；eg：购物车商品结算等。computed函数不能有异步
  
   watch：监听一个值的变化执行对应的回调；每次监听的值发生变化时都会调用回调；watch中可以没有return；一般用于当一条数据影响多条数据的时候 eg：搜索框。watch支持异步




对vuex的理解

  专门为vue提供的全局状态管理系统，用于多个组件中的数据共享，数据缓存




vuex 的五个属性的作用
  1.state:存放组件之间共享的数据 采用单一状态树
  2.getter:相当于vuex中的计算属性 对state里面的数据做处理再返回，默认传state：访问数据，getters：访问函数
  3.mutation：放置改变数据方法的集合，存放处理数据的各种方法，使用$store.commit来触发方法，必须是同步函数
   4.action：提交mutation中的方法，不用直接变更状态，可以包含任何异步操作，通过$store.dispatch方法触发
    5.module：模块  解决store对象臃肿的问题


    1.state：数据贮存；2.getter：state的计算属性；3.mutation：提交更改数据的方法；更改state中状态的逻辑，同步操作；4.action：提交mutation，异步操作 ；5.module：模块化vuex



v-for 与 v-if 在同一标签中 哪个先执行
   v-for优先级比v-if高

v-show 与 v-if 的区别
   v-show:改变的是元素属性display，显示为block，隐藏为none,元素还存在dom中；v-show只是简单的基础css切换，由false变true时不会触发组件的声明周期
    v-if:显示隐藏是将整个dom元素添加或删除；v-if是真正的条件渲染，在切换过程中条件块内的事件监听和子组件适当地被销毁和重建；由false变true或true变false时会触发组件的生命周期钩子函数



谈谈对组件的理解

  组件化开发可以大幅度提高应用开发效率、测试性、复用性。
  常用的组件化技术：自定义属性，自定义事件，插槽
  高内聚、低耦合、单向数据流


keep-alive平时在哪里使用，原理是什么
 
   使用keep-alive包裹动态组件时，会对组件进行缓存，避免组件重新创建
   两个场景：动态组件，router-view