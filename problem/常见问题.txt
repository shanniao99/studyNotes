html：
div和span区别
      div：块级元素，每个div标签会独占一行，可通过css样式来设置自身宽度、高度，标签之间的内外边距，还可以在div标签中使用其他行内或块级元素。
      span：行内元素，会和其他标签元素在一行显示，不会另起一行，span标签无法设置高度和宽度，可以设置左右的内外边距，但不能设置上下的内外边距，span标签内只能容纳文本或其他行内元素，不能容纳块级元素。


css布局方式有几种？
       静态布局（float布局，绝对布局），自适应布局，流式布局（百分比布局%），响应式布局（媒体查询），弹性布局


css的使用方式哪几种
      1.行内样式：只对当前标签生效
      2.内联样式：将css代码集中写在html文档的head头部标签中
      3.外链样式：将所有样式放在一个或者多个css文件中，通过link标签连接到html文档中

选择器有哪几种？
       1. 元素选择器    标签名{ }
       2. id选择器          #id{ }
       3. 类选择器          .类名{ }
       4.分组选择器（常用于集体声明）  选择器1，选择器n { }
       5.复合选择器（交集选择器）   选择器1选择器2选择n
       6.通配选择器        *{ }
       7.后代选择器（选中指定元素的指定后代元素）       祖先元素  后代元素{ }
       8.子元素选择器     父>子{  }
       9.伪类选择器   :hover  鼠标移入元素的状态，:visited已被访问的元素状态， :active 被惦记时元素的状态
       10.属性选择器 （根据元素中的属性或属性值来选取指定元素）
       11.兄弟元素选择器   “+”选择器（作用在后一个）：（选中一个元素后紧挨着的指定兄弟元素） 前一个+后一个{  }  ；“~”选择器：选中后面所有的指定兄弟元素  前一个~后边所有
    

优先级怎么算？

       css属性+!important>内联样式>ID选择器>类选择器=伪类选择器=属性选择器>元素选择器=伪元素选择器>通用选择器>继承的样式


rem单位是怎么换算的？
........


微信小程序rpx是怎么换算的？



用过哪些css3属性

      text-overflow：规定当文本溢出包含元素时发生的事情、text-shadow：文本阴影、border-radius：圆角边框、box-shadow：方框阴影、background-size：背景图片的尺寸、transform：2D、3D转换、transtion：过渡属性（四个）、@keyframes：动画、box-sizing


弹性布局有哪些属性
1. flex-direction:项目的排列方向（主轴的方向）
	        row：主轴为左端水平方向
           row-reverse：主轴为右端水平方向
                       column：主轴为上沿垂直方向
    column-reverse：主轴为下沿垂直方向

2.flex-wrap：轴线上的换行方式
                      nowrap：（默认）不换行
                           wrap：换行，第一行在上方
        wrap-reverse：换行，第一行在下方

3.flex-flow：flex-direction属性和flex-wrap属性的简写，默认：row nowrap

4.justify-content：项目在主轴上的对齐方式
                  flex-start：（默认）左对齐
                    flex-end：右对齐
                         center：居中对齐
     space-between：两端对齐，项目之间间隔相等
        space-around：四周型对齐方式  项目两侧的间隔相等

5.align-item：项目在交叉轴上的对齐方式
                   flex-start：交叉轴的起点对齐（垂直顶端对齐）
                     flex-end：交叉轴的终点对齐（垂直底端对齐）
                         center：交叉轴的中点对齐（垂直居中对齐）
                      baseline：项目的第一行文字的基线对齐
                        stretch：（默认）如果项目未设置高度或auto，将占满整个容器的高度

6.align-content：多根轴线的对齐方式
                    flex-start：与交叉轴的起点对齐（垂直顶端对齐）
                      flex-end：与交叉轴的终点对齐（垂直底端对齐）
                           center：与交叉轴的中点对齐（垂直居中对齐）
       space-between：与交叉轴两端对齐，间隔平均分布
           space-around：四周型对齐方式
                          stretch：（默认）轴线占满整个交叉轴

7.order：定义项目的排列顺序。数值越小，排列越靠前，默认为0
8.flex-grow：项目的放大比例，默认为0
9.flex-shrink：项目的缩小比例，默认为1
10.flex-basis：定义在分配多余空间之前，项目占据的主轴空间（main size），默认auto，即项目本来大小
11.flex：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选
12.align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认auto：表示继承父元素的align-items属性


order属性干嘛的
     order：定义弹性布局中项目的排列顺序。数值越小，排列越靠前，默认为0



媒体查询怎么写？
    @media mediatype and/not/only (media feature){ css样式}
   
    @media:声明媒体查询
    mediatype：规定媒体的类型，包括：all（所有设备）、print（打印机）、screen（屏幕）、speech（屏幕阅读器）
    media feature：媒体特性  写法：属性名：属性值（min-width：700px）
    逻辑运算符：not：排除某种设备；only：指定某种特定设备；and：连接多种媒体特性，一个媒体查询可包含0或多个表达式



js数据类型有哪几种？
      number（数值）、string（字符串）、undefined（未定义）、null（空值）、bool（布尔值）、object



新增的h5标记
    header：网站头部区域、nav：网站导航、section：网页的某一模块、footer：网页的页脚等
    


css：
box-sizing盒模型

    将border、padding计算到width和height中，使页面更灵活。
    该属性包括content-box和border-box两个值
    content-box：定义width和height时，宽度不包括border和padding
    border-box：定义width和height时，border和padding被包含在宽高以内
  

常用的几种布局方式

       静态布局（float布局，绝对布局），自适应布局，流式布局（百分比布局%），响应式布局（媒体查询），弹性布局


css的选择器种类和优先级判定
    
     选择器：元素选择器、id选择器、类选择器、后代选择器、子代选择器、兄弟选择器、相邻选择器、群组选择器、全局选择器、属性选择、伪类选择器、选择器优先级

      优先级：!important>行间样式> ID选择器>属性选择器&&伪类选择器>类选择器>元素选择器



不知宽高的盒子如何居中(水平和垂直)

flex 布局 12个属性

css 的适配方案



js:
DOM和BOM
   
   DOM：文档对象模型。定义了处理网页内容的方法和接口
   BOM：浏览器对象。将浏览器当做对象来使用，定义了与浏览器进行交互的方法和接口
   DOM的最根本对象是BOM的window对象的子对象


js的事件流
   
   事件流：事件的执行流程顺序
   1 捕获事件：从外往里触发事件
   2 目标事件：直接绑定在元素上的DOM0级事件
   3 冒泡事件：从里往外触发事件（默认）
   
  事件捕获：从最外层往里层，事件冒泡：从最里层到最外层
   

this和target指向
    this:指向当前事件所绑定的元素；
    target：指向事件执行时点击区域的元素
    当鼠标所点击的元素有子元素时，target指向子元素，没有则跟this指向一样

     this指向事件源
     event.target永远指向事件触发时最底层的元素

数组和字符串常用的api

  数组：arr.push()数组末尾添加元素----arr.unshift:数组开头添加一个元素----arr.shift:删除并返回第一个元素----arr.pop()删除并返回最后一个元素----arr.reverse()反序排列数组元素----arr.sort()正序排列数组----arr.splice()截取数组片段----arr.slice()复制数组片段----arr.concat()多个数组合并----arr.join()连接数组形成字符串。
   数组遍历：forEach----find：查找第一个符合return的结果并返回----filter：查找并返回所有符合return的结果----findIndex：查找并返回第一个符合return结果的索引值----some:return结果为true时停止遍历并返回true，没有则false----every：return为false时返回false，没有为true----map：把return的结果返回形成新数组
   
   字符串：str.length:读取字符串长度----str.indexOf():读取字符所在索引值，没有为-1----str.toUpperCase:大写----str.toLowerCase:小写----str.substr:复制字符串片段（从索引值开始到该后面几个成员）----str.substring:复制片段（从索引值开始到整个字符串第几个成员）----str.split()分割字符串形成数组----str.replace（）:替换字符串


闭包(是什么,能用来做什么,会产生什么影响)

   闭包是指有权访问另外一个函数作用域中的变量的函数
   闭包可以读取函数内部的变量，同时让这些变量的值始终保持在内存中
   由于该功能，内存消耗很大，滥用闭包可能会导致内存泄漏问题


跨域(为什么会产生跨域,跨域的解决方案)

   跨域是指一个域下的文档或脚本试图去请求另一个域下的资源

   跨域是为了解决不同源网页之间可以授权读取对方资源的操作
   解决方案：1.JSONP---get请求；2.CORS 跨域资源共享。。。


get和post请求的区别

  get：不安全，数据暴露；传送的数据量小，限制form表单的数据集的值必须是ASCII字符；执行效率比post方法好
  post：保密性好，数据不易泄露；传输数据量较大；支持整个ISO10646字符集。


工厂模式，构造函数，原型函数...

  工厂模式：在函数内创建一个对象，给对象赋予属性及方法再将对象返回
  构造函数：

call和apply的区别
   
  都是调用函数，传递参数，借用其他函数的方法，改变函数内部的this指向。
  call传递的参数用逗号隔开，apply方法执行传递数组

js方法的继承
  1.构造函数方法继承（用call()方法）将父构造函数的this指向子构造函数的实例，从而实现继承
  2.原型链继承：
  3.组合继承等

==和===的区别
==：等值   ===：等值及等址

node：
常用的模块有哪些
   http  fs  path  url mime querystring art-template  multer  jsonwebtoken
   http：网络通信  fs:文件读写  path:路径  url:请求地址
   querystring：实现URL参数字符串与参数对象的互相转换
   mime：动态读取文件类型
   art-template：模板渲染数据
   multer：文件上传
   jsonwebtoken：token令牌


本地安装和全局安装的区别
  1.安装位置不同，本地是将模块下载到当前命令行所在的目录，全局模块被下载安装到全局目录中。
  2.调用方式不同：本地安装可通过require()的方式引入，全局安装不行
 


什么是错误优先的回调函数？
   错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据，其中第一个参数返回错误，并且验证它是否出错；其他参数返回数据。



express的功能
  是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。



怎么操作mongodb（增删改查）
deleteOne：删除一条  deleteMany：删除多条
updateOne，updateMany：更新
findOne，find：查找



es：
var 和 let const的区别
  var定义的变量可以有变量提升（可以预解析提前调用的结果是undefined）  let和const定义的变量不能预解析；
  var定义的变量，其名称可以重复，效果是重复赋值，let和const定义的变量名不能重复，否则报错；
  var定义的变量作用域：全局/局部，let和const定义的变量只能在块中使用（{}）；
  var定义的变量在循环中和let定义的变量执行原理和执行效果不同
  const定义的变量存储的数据数值不能改变，也就是不能重复赋值。


js的几种作用域

全局、局部、块级

  

新增数据类型

 Symbol：表示独一无二的值

箭头函数与普通函数的区别
  this指向不同，箭头函数中没有this；箭头函数不能作为构造函数，不能使用new关键字；不绑定arguments，如果存在多余参数，可以使用rest解决；箭头函数会捕获上下文的this作为自己的this；箭头函数没有原型对象，不能在原型对象上添加方法，不能作为生成器函数。


结构赋值


Symbol的作用

promise 封装ajax



异步 (async await promise)

es类的继承

set和map区别



vue：
data为什么是函数
        vue中组件是用来复用的，为了防止data复用，将其定义为函数

常用v指令
       v-bind、v-on、v-if、v-for、v-show、v-model、v-html、v-once


写过哪些常用自定义指令
       v-big：字母小写转大写
       v-sum：计算两数之和

vue双向数据绑定原理
       页面上控件输入的值同步更新到相关绑定的data属性，在更新data绑定属性时同步更新页面上输入控件的值


vue 生命周期(哪一步能做什么)
        beforeCreate： vue实例初始化之前调用；
        created：              vue实例初始化之后调用；
        beforeMount：    挂载到dom树之前调用
        mounted：            挂载到dom树之后调用
        beforeUpdate： 数据更新前调用
        updated：             数据更新之后调用 
        beforeDestroy：vue实例销毁之前调用
        destroyed：         vue实例销毁之后调用


vue 父子组件的生命周期执行顺序
    父 beforeCreate-->父 created-->父 beforeMount-->子beforeCreate-->子created-->子 beforeMount-->子 mounted-->父mounted-->父beforeUpdate-->子 beforeUpdate-->父updated-->子 updated-->父beforeDestroy-->子 beforeDestroy-->子 destroyed-->父destroyed

vue 父子传值

    一、父传子
          1.通过自定义属性传值，子组件通过props接收
          2.子组件通过slot插槽标签接收父组件标记里面的内容
    二、子传父
          1.子组件通过$emit自定义事件触发，父组件随时监听事件执行来实现传值
          2.通过ref命名传值（父组件触发）
    三、子传子
           通过事件总线的方式传值（需要修改main.js）


vue路由跳转

       path跳转页面
       name跳转页面  


vue路由跳转接收参数
    布尔模式：name传参，当props设置为true时，route.params 将被设置为组件的 props。
    函数模式：path传参，创建一个返回props的函数，path属性配合query传值
    对象模式：当props是一个对象时，将原样设置为组件props


vue路由导航钩子函数
       全局钩子：beforeEach、afterEach、beforeResolve
       局部钩子：beforeEnter
       组件路由：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave


vue-router 实现原理
      原理：vue-router是前端路由，当路径切换的时候在浏览器端判断当前路径，并加载当前路径对应的组件，有两种模式：
       hash模式：以url中#后面的内容作为路由地址，可以直接通过location.url来切换浏览器的地址，当hash改变后，要监听hash的变化，并做响应的处理，可以监听hashchange事件，当hash发生变化时，会触发hashchange事件，在此事件中记录当前路由地址，并找到当前路由对应的组件，重新渲染在浏览器中。 可通过mode:"history"的方式更改hash模式为history模式。

        history模式：路径就是普通的url，通过history.pushState()方式来改变地址栏，并把当前地址记录在浏览器的访问历史中，并不会真正的跳到指定的路径，也就是说浏览器不会向服务器发送。




watch 与 component 的区别
    watch：侦听器；观测vue实例中数据的变化，数据一旦变化就执行function中的语句，函数中提供new和old两个参数（改变后和改变前的数据）
    component：组件；组件可以扩展HTML元素，封装可重用的代码。


vuex 的五个属性的作用
  1.state:存放组件之间共享的数据 采用单一状态树
  2.getter:相当于vuex中的计算属性 对state里面的数据做处理再返回，默认传state：访问数据，getters：访问函数
  3.mutation：放置改变数据方法的集合，存放处理数据的各种方法，使用$store.commit来触发方法，必须是同步函数
   4.action：提交mutation中的方法，不用直接变更状态，可以包含任何异步操作，通过$store.dispatch方法触发
    5.module：模块  解决store对象臃肿的问题
v-for 与 v-if 在同一标签中 那个先执行


v-show 与 v-if 的区别
   v-show:改变的是元素属性display，显示为block，隐藏为none,元素还存在dom中；v-show只是简单的基础css切换，由false变true时不会触发组件的声明周期
    v-if:显示隐藏是将整个dom元素添加或删除；v-if是真正的条件渲染，在切换过程中条件块内的事件监听和子组件适当地被销毁和重建；由false变true或true变false时会触发组件的生命周期钩子函数